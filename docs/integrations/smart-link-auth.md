---
id: smart-link-auth
title: SmartLink Authentication
sidebar_label: SmartLink Authentication
slug: /integrations/smart-link-auth
---

## Introduction

In this document we will explain everything you need to know about SmartLink 
authentication mechanism: what it is, what it provides, how it works, and how
to use it.

## What it is

SmartLink is a Single sign-on (SSO) authentication mechanism provided by the 
nVotes platform that uses a Keyed [HMAC](https://en.wikipedia.org/wiki/HMAC) 
authentication token. It allows you to send voters that 
are already authenticated  in your own platform or website to a voting link 
for a specific election without forcing them to authenticate again in nVotes 
Platform. It is a secure and simple way to implement Single sign-on.

:::note Other Single sign-one methods
nVotes Platform also supports the 
[OpenID Connect authentication method](/docs/file-formats/election-creation-json#census-auth_method) 
to implement Single sign-on.
:::

## How it works

SmartLink is a native authentication method in nVotes platform. Voters will be 
authenticated through a link that includes a secure authentication token (the 
`auth-token`), but  **authorization is done by nVotes platform**. This 
means that the administrator need to upload the census in nVotes platform.

The authentication flow compromises the following steps:
1. Voters are asumed to start by being already authenticated in your website or 
platform (the `external application`).
2. In the external application, voters launch the action to vote, and this 
redirects them to a SmartLink in nVotes Platform.
3. The nVotes platform loads the SmartLink, performing authentication and 
authorization and automatically redirecting to the voting booth when 
authentication and authorization succeed.

A more detailed sequence diagram of the steps involved is shown below:

<div style={{textAlign: 'center'}}>

![SmartLink Sequence Diagram](./assets/smartlink-sequence-diagram.png)

</div>

As can be seen in the sequence diagram, the single interaction of the voter
clicking in the action to Vote inside the External Application triggers a 
series of events that ends up loading nVotes User Interface (UI) with an 
internal authentication token. 

After the final step shown in the sequence diagram (number 10), nVotes UI will
automatically load the voting booth and the voter's will be vote correctly 
authenticated when cast.

### `auth-token` overview

The auth-token is generated in the external application, and verified by nVotes
platform. It is a cryptographically secure to transmit information between the 
external application and nVotes plataform.

The following data is securely transmitted through the auth-token:
- `user-id`: A unique identifier string of the voter. This is the way nVotes
platform matches the user with the previously census loaded in the election.
- `election-id`: The identifier of the election in which the voter will be 
authenticated in and in which he is eligible to participate.
- `timestamp`: Timestamp in which the token was generated. It allows the toke
to expire.

There are some other related data fields, but we will delve into the details 
later. 

All this data is signed by the usage of a keyed hash-based message 
authentication code (also called a keyed 
[HMAC](https://en.wikipedia.org/wiki/HMAC)). An HMAC is a cryptographic
mechanism that uses the fact that 
[hash functions](https://en.wikipedia.org/wiki/Hash_function) are 
[one-way functions](https://en.wikipedia.org/wiki/One-way_function) to use the
hashing as a secure signature mechanism. A one-way function is a function that
is easy to calculate in one direction, but very difficult or impossible to 
calculate in the opposite direction. Hash functions are one-way functions.

The external application will generate the message to be signed, then hash it
using the HMAC mechanism and the HMAC signature. The auth-token is 
composed by both the message and the HMAC code (or HMAC for short).

We use a keyed HMAC, which means that the hashing is of two things together:
1. The message
2. A shared secret, that only the external application and nVotes platform know.

Because hash functions are one-way functions, the resulting HMAC can only
be calculated having access to the hashed data. The HMAC serves as a 
signature because part of the hashed data (the shared secret) is secret. nVotes 
platform can authenticate that the message was generated by an authorized
party by receiving the authentication token, and calculating the HMAC by
using the message included in the auth-token with the shared secret. If
the resulting HMAC matches the hash included in the auth-token, then nVotes 
platform has successfully verified that the hash was generated by someone with 
access to the shared secret, which means the external application in our case.

The auth-token cannot be generated in the web-client of the
external application, because that would mean that the shared secret would be
accessible by the voter. The shared secret cannot be accessible by anyone else 
but nVotes Platform and the external application backend servers. The shared 
secret needs to  remain in the backend servers and not leave them. Of course, 
in nVotes platform the same principle applies, and only the backend servers can 
and do verify the auth-token.

## Integration

The steps 4 to 7 as shown in the sequence diagram from the 
[how it works section](#how-it-works), need to be implemented in the external
application.

### Step 4: Showing the vote action

<div style={{textAlign: 'center'}}>

![SmartLink Sequence Diagram: Step 4](./assets/step-4.png)

</div>

At this step we start assuming the voter is correctly authenticated in the 
external application and the external application is being run in the voter's 
device.

The voter should be presented an action to be able to request to vote. This can
be a button or any other user interface representation. This action to vote MUST 
only be enabled during the voting period in which this specific voter can 
participate, and the action must be related to a specific election.

The nVotes platform assumes that the vote action will not be enabled once 
the voting is finished. If for some reason the action is activated when the
election is not within the voting period, the authentication will fail and the
voter will be redirected to the election public page.

In nVotes platform voters can in some cases vote multiple times, depending on the 
[election configuration](/docs/file-formats/election-creation-json##election-num_successful_logins_allowed). In any case, only the last vote cast by each voter will be counted. This is 
therefore not a security breach, but on the contrary a typical security measure 
in secure electronic voting systems to mitigate coercion, and we comment on it 
because it implies that in the cases where vote changing is allowed, the access
to the vote action should not disappear when the voter has voted. The reason is 
simple: the voter can change his/her vote by casting another vote during the 
voting period.

According to the above, it is not strictly necessary for the application to 
monitor whether the voter has already clicked on the vote button, or whether 
the voter has clicked on the vote button but has not finished voting, or whether
the voter has clicked on the vote button and has effectively cast the vote 
correctly. The external application can simply show the vote button whenever an
election is in progress.

In some cases, it is required that each voter can cast only one vote. As 
mentioned earlier, this is configurable in the election configuration. If this
is done and the voter has already voted, then when the voter accesses a second
time to the SmartLink it will show a generic authentication error message saying 
that the authentication did not succeed, mentioning multiple possible reasons 
why this error might happen.

Authentication error messages are explicitly vague for security reasons. Showing
different error messages might unintentionally reveal information to an 
attacker.

### Step 5: Requesting the SmartLink

<div style={{textAlign: 'center'}}>

![SmartLink Sequence Diagram: Step 5](./assets/step-5.png)

</div>

When the voter clicks the vote action button, the external application should
request to the external application backend servers the SmartLink. The SmartLink
should:
1. Not be pre-generated or preloaded, as the SmartLink contains the auth-token
and the auth-token has a limited lifetime for security reasons related to it 
being a bearer token.
2. Should be generated in the backend and not in javascript in the web browser
of the voting device, because the generation of the SmartLink requires access
to the shared secret and the shared secret should not leave the backend servers.

The connection betweeen the external application user interface and the 
external application backend servers should be encrypted end-to-end, typically 
using TLS, so that the bearer token cannot be sniffed by any third-party 
attacker.

Of course, this request must be properly authenticated using whichever
authentication procedures that the external application uses internally.

### Step 6: Generating and returning the SmartLink

<div style={{textAlign: 'center'}}>

![SmartLink Sequence Diagram: Step 6](./assets/step-6.png)

</div>

The external application backend servers receive the SmartLink generation 
request and need to safely process it, generate the SmartLink and return the 
SmartLink to the external application user interface.

First, the request needs to be validated and authenticated. Failing to correctly
verify the authentication of the request to generate the SmartLink would 
generate a security vulnerability, because an attacker could receive a 
SmartLink to vote in place of other voters. It's the responsability of the
external application to setup proper request authentication verification 
mechanisms.

Once the request is authenticated, then the application needs to
verify that voter is eligible to vote in the specific requested election and 
that this specific election is in the voting period. In nVotes platform, 
elections are identifed by the `election-id`, a positive integer that 
identifies the election.

#### The SmartLink format

The SmartLink is a string with the following pattern:

```
https://example.com/election/<election-id>/public/login?auth-token=<auth-token>
```

For example, if nVotes platform is deployed in the domain 
`vote.university.com`, and the election id is `150017`, the SmartLink for a
voter whose `user-id` is `example@nvotes.com` would look similar to the 
following:

```
https://vote.university.com/election/150017/public/login?auth-token=
khmac:///sha-256;8e0b1b553c29046cf5988a0e24d6ce276f6d14d27918da5d219
b634970c3f706/example@nvotes.com:AuthEvent:150017:vote:1620805691
```

For the same election, the only part that varies in each smart link is the
`auth-token`.

#### The `auth-token` format

Please refer to the [auth-token overview](#auth-token-overview) section in which
we explain how the auth-token works.

The auth-token is a string that has the following format:

```
khmac:///sha-256;<code>/<message>
```

The code is generated by applying the HMAC function to the message plus the
shared secret. The code is generated with the standard HMAC procedure with the 
SHA-256 hashing function, further defined in the 
[U.S. Federal Information Processing Standards Publication 198](https://web.archive.org/web/20201208050119/http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf). 

We provide two examples of how to generate the auth-token:
- [Auth-token generation in Rust language](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=bb69ae8415e95815ee8d1d722873c79b)
- [Auth-token generation in Go language](https://play.golang.org/p/lp44mNTxfeu)

In other programming languages it is possible to generate the HMAC in a 
similar way, as it is a standard security mechanism.

#### The `auth-token` message format

The message is the string to be signed using the HMAC procedure. It has the 
following format:

```
<user-id: String>:AuthEvent:<election-id: Int>:vote:<timestamp: Int>
```

For example, a valid message could be:

```
example@nvotes.com:AuthEvent:150017:vote:1620927640
```

As can be seen there are three pieces of information within the message:
- **user-id** It is a text string used by nVotes Platform as an identifier of 
the voter. There are several important considerations with regards to the 
user-id:
  1. The user-id must always be the same for each voter on each election. That 
  is, if a voter votes twice in the same election, the user-id must be the same. 
  The user-id is the way nVotes Platform will find if the voter previously 
  voted, and in that way nVotes Platform decides whether to save the vote as a 
  new vote or overwrite the voter's previous vote.
  2. The user-id is the lookup field by which nVotes will try to find the voter
  in the census to perform authorization. If the user-id is not included in the 
  census of the election, authorization will fail. If the user-id is from 
  another voter, the voter would be voting in place of this other voter. Thus, 
  it's critical to correctly set this field.
  3. To avoid transmitting any additional information about the voter beyond a 
  unique identifier, the voter id can be a hash of a unique internal identifier 
  of the voter, known only to the external application. In this manner this 
  information does not have to transcend outside the external application. For 
  example, the affiliate number in an assocation or internal database unique 
  user id can be used.
  4. We recommend using SHA-256 as a hashing function, and avoiding SHA-1 or MD5 
  for security reasons.
  5. We recommend that you do not directly hash the voter's id, but rather hash 
  the id plus a salt. The salt must be another secret key, which is only known 
  by the external application servers, and thus protects against attacks that 
  reveal the voter's id.
  6. It is recommended that the salt varies for each election. That way in each 
  election the user-id for the same voter will be different, thus reducing the 
  information revealed through the user-id to nVotes platform strictly to the 
  minimum necessary. Therefore, it is recommended that you include the
  election-id in the salt to be hashed.
- **election-id** The unique identifier of the election. It is necessary to 
include it so that the message, which is trusted by nVotes platform because it 
is cryptographicall signed, associates the user-id to a specific election, and 
thus the same message cannot be used for different elections in the event that
there are two or more elections running at once. The election-id will be 
provided by nVotes Platform for each election, and it will be a positive
integer.
- **timestamp** It is the date on which the message was generated, in 
"UNIX timestamp" format, that is, an integer with the number of seconds since 
January 1, 1970 ([more information](https://en.wikipedia.org/wiki/Unix_time)).
The message includes the timestamp as a way to calculate an expiration date 
for said authenticated message, as we have explained previously. The auth-token 
needs to expire because it is a bearer token, meaning that anyone with access 
to it will be able to use it. For this reason its lifetime needs to be
limited. It's important to verify that the clocks of both backend servers (that 
of nVotes Platform and that of the external application) are synchronized, so 
that the message expiration calculation is possible.

### Step 7: Loading the SmartLink

<div style={{textAlign: 'center'}}>

![SmartLink Sequence Diagram: Step 7](./assets/step-7.png)

</div>

Once the external application receives the SmartLink, the next step is very
simple: load the SmartLink URL. This can be performed using one of the following 
methods: 
- Load the URL in a web browser widget if the external application is a native
mobile or desktop application and you don't want to move the voter to a web
browser.
- Load the URL in a new web browser window if the external application is a
native mobile or desktop application and you don't mind moving the voter to a
web browser.
- Load the URL in a new tab if the external application is a website and you
don't want the voter to close the external application tab.
- Load the URL changing the current `window.location.href` if the external 
application is a website and you don't mind closing the external application
website.

Note that currently you **cannot** load the SmartLink in an iframe, as it would
interfere with other integration methods and would not work.